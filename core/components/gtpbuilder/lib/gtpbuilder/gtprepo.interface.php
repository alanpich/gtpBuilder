<?php
/**
 * Interface for gtpBuilder to talk to git repo hosts
 * 
 * @author Alan Pich <alan@alanpich.com>
 * @copyright (c) 2013, Alan Pich
 * @date 25-Nov-2012
 * @interface
 */
interface gtpRepoInterface {
    
    /**
     * Set Authentication credentials for repo access.
     * This is aimed at HTTP basic authentication
     * @param string $username
     * @param string $password
     * @return void
     */
    public function setAuthCredentials($username,$password);
    
    
    /**
     * Get the SHA id of the latest commit on a branch
     * @param string $owner
     * @param string $branch
     * @param string $repo
     * @return string SHA commit ID or false
     */
    public function getLatestCommitId($owner,$branch,$repo);
    
    
    /**
     * Retrieve a source file archive from host
     * @param string $owner
     * @param string $repo
     * @param string $sha
     * @return string Archive source (for saving) or false
     */
    public function downloadArchive($owner,$repo,$sha);
    
    
    /**
     * Extract a downloaded archive specified by filepath
     * @param string $pathToArchive
     * @return boolean success
     */
    public function extractArchive($pathToArchive);
    
    
    /**
     * Return array of error/warning messages generated
     * @return array
     */
    public function getMessages();
    

    
    
}; // end interface GitInterface


abstract class gtpRepo {
    
    /**
     * Base URL for cURL requests
     * @const string
     */
    const baseUrl = '';
    
    const LOG_INFO = modX::LOG_LEVEL_INFO;
    const LOG_WARN = modX::LOG_LEVEL_WARN;
    const LOG_ERROR = modX::LOG_LEVEL_ERROR;
    
    /**
     * Store a single instance of this class
     * @static self Instance
     */
    protected static $_instance = null;
    
    /**
     * Array of messages/warnings generated by class
     * @var array
     */
    protected $messages = array();
    
    /**
     * Authentication username & password for repo access
     * @var string
     */
    public $auth_user = null;
    public $auth_pass = null;
    
    protected $gtp;

    
    public function __construct(){
        $this->gtp = gtpBuilder::getInstance();
    }
    
    /**
     * Exec cURL request with following redirects
     * @param resource $ch cURL request object
     * @param int $redirects Number of completed redirects
     * @return string
     */
    protected static function curl_redirect_exec($ch, &$redirects) {
        $self = self::getInstance();
        curl_setopt($ch, CURLOPT_HEADER, true);
        $data = curl_exec($ch);
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        if ($http_code == 301 || $http_code == 302) {
            list($header) = explode("\r\n\r\n", $data, 2);
            $matches = array();
            preg_match('/(Location:|URI:)(.*?)\n/', $header, $matches);
            $url = trim(array_pop($matches));
            $url_parsed = parse_url($url);
            if (isset($url_parsed)) {
                curl_setopt($ch, CURLOPT_URL, $url);
                $redirects++;
                return $self->curl_redirect_exec($ch, $redirects);
            }
        }
        list(,$body) = explode("\r\n\r\n", $data, 2);
        return $body;
    }
    
    /**
     * Make a cURL request and return data
     * @param string $url URL to request
     * @param boolean $parseJSON Attempt to parse as json
     * @return mixed
     */
    protected static function fetch($url,$parseJSON = true){
        $self = self::getInstance();
        // Prepare url
        $url = $self::baseUrl.str_replace($self::baseUrl,'',$url);
        // Check php has been compiled with cURL
        if(!function_exists('curl_version')){
            throw new Exception('cURL extension not found'); }//
        // Make request using cURL
        $ch = curl_init();
        curl_setopt($ch,CURLOPT_URL,$url);
        curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false);
        curl_setopt($ch,CURLOPT_USERAGENT,"MODX transport packages builder direct from GitHub/1.0");
        if(!empty($self->auth_user)){       
            curl_setopt($ch, CURLOPT_USERPWD, $self->auth_user.":".$self->auth_pass);
        }
        $redirects = 0;
        $content = $self->curl_redirect_exec($ch,$redirects);
        curl_close($ch);
        
        if($parseJSON!==true){ 
            // Test for error message
            $json = json_decode($content);
            if(!is_null($json) && isset($json->message)){
                throw new Exception($json->message);
            };
            return $content;
        };
        
        if(empty($content)){ throw new Exception('Empty response'); };
        // Parse json
        $data = json_decode($content);
        if(is_null($data)){ throw new Exception('Invalid JSON response');};
        if(isset($data->message)){ throw new Exception($data->message); };
        // Return response object
        return $data;
    }//
    
      
    /**
     * Maintain a single instance of this class
     * @return self Instance
     */
    public static function getInstance(){
        $class = get_called_class();
        if(is_null($class::$_instance)){
            $class::$_instance = new $class();
        };
        return $class::$_instance;
    }//
    
    
    /**
     * Log an error message
     * @param string $msg The message
     * @param int $type Accepts self::LOG_* constants
     */
    private static function addMessage($msg,$type = modX::LOG_LEVEL_INFO){
       $obj = new stdClass;
       $obj->message = $msg;
       $obj->type = $type;
       $this->messages[] = $obj;
    }//
    
    
    public function getMessages(){
        return $this->messages;
    }
    
    protected function log($msg){  $this->gtp->log($msg); }//
    protected function warn($msg){  $this->gtp->warn($msg); }//
    protected function error($msg){  $this->gtp->error($msg); }//
    
    
};// end class gtpRepo
